---
title: "Linear Least Squares Problems"
html-math-method:
  method: mathjax
  url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"

---

{{< include _macros.qmd >}}

We begin our exploration of scientific machine learning methods in the fundamental setting of *linear regression problems*. The intended learning outcomes of these notes are that students should be able to:

1. Classify a regression problem as linear or nonlinear

2. Understand the abstract form of linear least squares problems

    a. Define the abstract form of linear least squares problems and be able to explain what its key ingredients are

    b. Translate a description of a model learning problem in words into a specific instance of the abstract form

    c. Construct examples of linear least squares problems, cast them in the abstract form, and explain their context

3. Solve linear least-squares problems by deriving and solving the normal equations. 

4. Evaluate linear regression models by computing and interpreting mean error, mean relative error, and R^2 values on both training and test data sets.

## Classifying regression problems as linear vs nonlinear

We have previously introduced regression problems in a general way: recall that the three ingredients of (parametrized) regression problems are (1) paired input and output data, (2) the choice of a parametrized model class, and (3) a method for choosing a model from within that class. The classification of a regression problem as *linear* or *nonlinear* depends solely on ingredient (2), the parametrized model class: if the models in that class depend linearly on the model parameters, the regression problem is a linear regression problem.

::: {.callout-caution collapse="true"}
## Check your knowledge: Do you remember what it means for a function to depend linearly on a variable?

The function $f(z;\theta): \R^d\times\Theta\to\R$ is said to be *linear* in the parameters $\theta$ if, for all $a,b\in\R$ and all $\theta_1,\theta_2\in\Theta$, the following holds:  $f(z; a\theta_1 + b\theta_2) = af(z;\theta_1) + bf(z;\theta_2)$. 

Note that when we say a function is "linear", we have to specify in *what*. That is, we can also say $f(z;\theta)$ is linear in the *inputs* if, for all $a,b\in\R$ and all $z_1,z_2\in\R^d$, the following holds: $f(az_1 + bz_2;\theta) = af(z_1;\theta)+bf(z_2;\theta)$.
:::

The classification of regression problems as linear or nonlinear depends **solely** on the dependence of the functions in the parametrized model class on the **parameters**. That is, we can define functions that are *linear* in $\theta$ while being *nonlinear* in $z$. 

::: {.callout-note}
## Exercise
Consider the model classes (@eq-quad-models)-(@eq-perceptron) introduced previously. Are these model classes linear or nonlinear in the parameters? In the inputs?
:::

## Mathematical problem formulation
We are now going to introduce an *abstract* mathematical problem formulation that can be used to describe many *specific instances* of linear regression problems. This is a theme of the course and throughout computational mathematics and engineering: abstraction using the language of mathematics lets us isolate the core essence of the problem we're solving and develop powerful algorithms that can solve specific applications of those problems across a wide range of disciplines. I'll introduce the abstract formulation first, and follow it up with some specific examples. 

Ingredient 1 (the data set): let $\{(z_i,y_i)\}_{i=1}^N$ be a given data set of paired inputs $z_i\in\R^d$ and outputs $y_i\in\R$. 

Ingredient 2 (the parametrized model class): let $x:\R^d\to\R^n$ be a function that maps the $d$-dimensional input to an $n$-dimensional *feature vector*. For a fixed $x$, we will consider the following parametrized model class:

$$
\mathcal{F}_\beta := \{ x(z)^\top \beta : \beta\in\R^n\}
$$ {#eq-linreg-model-class}

Recall that @eq-linreg-model-class is read as "$\mathcal{F}_\beta$ is defined to be the set of all functions $f(z;\beta) = x(z)^\top\beta$ for all $\beta\in\R^n$." This is an abstract way to define the model class for *any* linear regression problem, as we will describe in more detail shortly. 

Ingredient 3 (the method of choosing the parameters): let $\beta^*$ be given by 

$$
\begin{aligned}
\beta^* &= \arg\min_{\beta\in\R^n} \frac1N \sum_{i=1}^N (f(z_i;\beta) - y_i)^2 \\
&= \arg\min_{\beta\in\R^N} \frac1N \sum_{i=1}^N (x(z_i)^\top\beta - y_i)^2.
\end{aligned}
$$ {#eq-linreg-minimization}
Then, we define the *learned model* to be $f(z;\beta^*) = x(z)^\top\beta^*$. We call $\beta^*$ defined this way the "optimal regression parameters" or just the "optimal parameters", because they are the result of solving an optimization problem. Note that the objective of this optimization function is *defined by the data*, and represents the average squared error of the model over the data set. 

Taken together, the three ingredients I have defined above define a *linear least squares problem*, which is a subclass of linear regression problems. We'll now give several examples of specific instances of linear least squares problems to illustrate how broadly applicable this abstract framework is.

## Examples 

### Example 1: Aerodynamic drag prediction

<!-- ![Image Source: [@erauAirfoil2024]](images/AirfoilDrag.png){fig-align="center" width=80%} -->

An important task in aerodynamic design is predicting lift and drag forces on a body moving through air. Let's consider a simplified problem where we are given an fixed airfoil design and our goal is to predict the drag force $F_d$ on the airfoil as a function of three parameters which describe its flight conditions:

* The angle of attack $\alpha$ 
* The density of the fluid $\rho$
* The freestream velocity of the air $v$

To put this problem in our abstract framework, we define $z = (\alpha,\rho,v)^\top$ to be a three-dimensional input, and take the output to be the drag force $y= F_d$. In order to define a regression problem, we require the existence of a data set $\{(z_i,y_i)\}_{i=1}^N$. Note that in this case $z_i = (\alpha_i,\rho_i,v_i)$. We assume that this data set is given.

In linear regression problems, defining the model class amounts to choosing a set of regression *features* by defining $x$. A simple choice takes the inputs themselves to be features: $x^{(1)}(z) = z = (\alpha,\rho,v)^\top$. This leads to a class of parametrized models with a three-dimensional unknown parameter vector $\beta\in\R^3$. The models in this class have the following form:

$$
f^{(1)}(z;\beta) = x^{(1)}(z)^\top\beta = (\alpha,\rho,v) \beta = \beta_1\alpha + \beta_2\rho + \beta_3 v.
$$

There are many other possible choices. For example, consider $x^{(2)}(z) = (\alpha,\rho, v, \alpha^2, \rho^2, v^2, \alpha\rho, \alpha v, \rho v)^\top$. This leads to a parametrized model class with a *nine*-dimensional unknown parameter vector $\beta\in\R^9$:

$$
\begin{aligned}
f^{(2)}(z;\beta) &= x^{(2)}(z)^\top\beta = (\alpha,\rho, v, \alpha^2, \rho^2, v^2, \alpha\rho, \alpha v, \rho v)\beta \\
&= \beta_1\alpha + \beta_2\rho + \beta_3 v + \beta_4\alpha^2 + \beta_5\rho^2 + \beta_6 v^2 + \beta_7\alpha\rho + \beta_8\alpha v + \beta_9 \rho v
\end{aligned}
$$

For either the above choices of features $x^{(1)}(z)$ or $x^{(2)}(z)$, we could then define and solve the minimization @eq-linreg-minimization to find the optimal regression parameters and define our learned model $f^{(1)}(z;\beta^*)$ or $f^{(2)}(z;\beta^*)$. 

::: {.callout-note}
## Understanding notation
Note that we use $\beta$ to denote the unknown parameters in both $f^{(1)}$ and $f^{(2)}$ above despite $\beta$ referring to different quantities in the definition of the different functions. This is a common notational shortcut --- while we could use the notation $\beta^{(1)}\in\R^3$ and $\beta^{(2)}\in\R^9$ to specify the different $\beta$ for the different functions, this can be cumbersome if we are considering many different options for the choice of features $x(z)$, and it's standard to just use $\beta$, where the definition of $\beta$ is implied by the context. One of the challenges in learning about machine learning and computational mathematics more generally is getting used to similar notation meaning different things in different contexts. That's one of the things that we'll practice in this course.
:::


### Example 2: Monitoring the Maximum Displacement of a Bridge

Least-squares regression is a powerful tool for estimating unknown quantities in many scientific and engineering disciplines beyond Aerospace. Let's instead say we are interested in accurately estimating the maximum displacement at the midpoint of a bridge under various input-conditions measured by sensors along the bridge. Suppose we can accurately gather the following inputs: 

* $L$ - **Load (kN):** The total weight applied to the bridge, measured through load cells at the entry and exit of the bridge. 
* $T$ - **Temperature (C):** the temperature at the midpoint of the bridge, measured through thermocouple sensors. 
* $f$ - **Frequency (Hz):** the dominant frequency present in the bridge, measured through accelerometers. 

We are interested in quickly estimating the **Maximum Displacement (mm)**, $D$, from these parameters. As we can see, the context of our problem has changed entirely, but we can still fit it into our existing framework by defining the input vector $z=(L, T, f)^\top$ and output $y=D$. If we take $N$ measurements throughout the year under various environmental conditions, we can again form some training dataset $\{(z_i, y_i)\}_{i=1}^N$ which we can use to define some feature-set $x(z)$ and then solve for the optimal weights that map $x(z)$ to $y$ identically to how we did in **Example 1**.  

### Example 3: Detecting Cardiac Arrhythmia using Health-Monitoring Devices 

Many health issues are often difficult to detect without extensive testing. However, with the increase in biometric data available from devices such as smartphones and smart-watches, it has become increasingly feasible to predict disease by leveraging this information. According to Johns Hopkins, "an arrhythmia is an abnormality in the timing or pattern of the heartbeat," which can be life-threatening. Let's now suppose we have developed a smart-watch that gathers the following health-data from its user: 

* $v$ - **Heartrate Variability (ms):** This is the variation in time between consecutive heart beats. If this value is low, it can be an indicator of stress or irregular heart conditions. 
* $r$ - **Resting Heart Rate (beats per minute):** the rate at which someone's heart beats in the absence of activity. 
* $b$ - **Respiratory Rate (breaths per minute):** the rate at which someone breathes. 

And suppose we are interested in the *probability* that a patient has an arrhythmia. 

::: {.callout-note}
## Estimating categorical outputs
Note that in this scenario, the patient either has an arrhythmia or does not. This is different from when we sought to estimate a continuous quantity like drag-force or the maximum displacement of a bridge. This is an example of a **classification** problem: problems in which the outputs belong to a specific category rather than a continuous numerical value. To represent such outcomes, we need to assign discrete numeric values (usually a 0 or a 1) to the training outputs to indicate whether or not something has occurred. In this case, we might assign a 0 when a patient does not have an arrhythmia and a 1 when the patient does have an arrhythmia. Because linear regression is a continuous estimator (i.e. it will always output a numerical value instead of exactly 0 or 1), we can interpret the output as the *probability* of a 1. 
:::

Let's say we have a large sample of many patients of various ages and demographics who have worn our smart-watch for a long period of time. For the $i$ th patient, suppose we have $v_i$, $r_i$ and $b_i$ collected from the device and we know whether or not they have a heart arrhythmia or not. Let's define each training output $y_i$ as the following: 

$$ 
y_i = \begin{cases} 1, \text{ patient has arrhythmia} \\ 0, \text{ patient has no arrhythmia} \end{cases}
$$

Even though these outputs are discrete/categorical, our training process is identical. We form a training dataset, $\{(z_i, y_i)\}_{i=1}^N$ and solve the least-squares regression problem using the discrete values for $y$ exactly how we did in **Example 1**. However, now when our model attempts to map $x(z)$ to $y$, it will give the best estimate for whether the output should be a 0 or a 1. Naturally, the model will have some uncertainty for inputs it has never seen before and will likely output a number *around* this range. Let's suppose we feed our trained model some unseen $z_{\text{new}}$ (e.g. a patient not in the training data), then form $x(z_{\text{new}})$, and lastly find that $x(z_{\text{new}})^\top \beta = 0.86$. This indicates a high probability of this patient having an arrhythmia, which may be vital information to relay to the patient or healthcare provider. This simple example shows how these machine learning algorithms can have a direct impact on the quality of human life. 


## Solving linear least squares problems

Linear least squares problems are special because they have closed form solutions: that is, we can write an analytical expression for the optimum parameters $\beta^*$ in terms of the data. To do so, we are going to define a feature data matrix $X\in\R^{N\times n}$ and an output data vector $Y\in\R^N$ as follows:

$$
X = \begin{pmatrix}
- &x(z_1) & - \\
 & \vdots & \\
- & x(z_N) & -
\end{pmatrix}, 
\qquad 
Y = \begin{pmatrix}
y_1 \\ \vdots \\ y_N
\end{pmatrix},
$$
where the *rows* of $X$ and the *elements* of $Y$ correspond to input-output pairs in the data set. Note that each *column* of $X$ corresponds to a different *feature* defined by an element of the vector-valued function 
$x$.

Using this notation, @eq-linreg-minimization can be rewritten as

$$
\beta^* = \arg\min_{\beta\in\R^n} \frac1N\|X \beta - Y\|^2 
$$ {#eq-linreg-matrix-min}

This is the minimization of a multivariate function (because $\beta$ is a vector). Recall from calculus that to find minimizers of multivariate functions we first seek *critical points* that satisfy the *first-order necessary conditions* for optimality: that is, we look for points where the derivative of the objective function is 0. Let $\mathcal{L}(\beta) = \frac1N\|X\beta-Y\|^2 = \frac1N(X\beta - Y)^\top (X\beta-Y)$. Then,

$$
\frac{\partial\mathcal{L}}{\partial \beta} = \frac2N(X^\top X\beta - X^\top Y)
$$

Setting the derivative equal to 0 yields the standard *normal equations*[^1]:

[^1]: note that the constant factor $\frac2N$ drops out. It's common to play fast and loose with multiplicative constants in minimizations -- other sources define the minimization objective with a $\frac12$ multiplier, which leads to the derivative not having the factor of 2 in front and leads to the same critical point. Or you may see the objective function defined without the $1/N$ in front, which still leads to the same critical point.

$$
X^\top X\beta^* = X^\top Y
$$

If $(X^\top X)$ is invertible, then the unique solution to the normal equations is given by

$$ 
\beta^* = (X^\top X)^{-1} X^\top Y
$$

and this choice of $\beta$ defines our final learned model: $f(z;\beta^*) = x(z)^\top\beta^*$.

### Using Python for Least-Squares Regression

Now let's explore how we can actually solve for our optimal weights, $\beta^*$, given some training data with code. First, we need to import the libraries we need to work with matrices/vectors (`numpy`), plot results (`matplotlib`), work with dataframes (`pandas`), and easily perform more math than base python allows like $\pi$, sines, cosines, and square-roots (`math`). 
```{python}
import numpy as np 
import matplotlib.pyplot as plt 
import pandas as pd
import math
```

Now let's say we've imported some pandas dataframe called `df` that contains a set of empirical data from **Example 1** (Assume it comes from experimental trials or simulations). We can print the first few rows of the dataset using the `df.head()` method: 

```{python}
#| echo: false
np.random.seed(42)

def Cd(alpha):
    return 0.1 * np.exp(math.pi / 180.0 * alpha)

def Fd(alpha, rho, v):
    C_d = Cd(alpha)
    A = 1.2 # m^2 
    return 0.5*rho*alpha*v**2*C_d +1

N = 100
alpha = np.random.rand(N)*45
rho = np.random.randn(N)*0.3 + 1.293 
v = np.random.rand(N)*100
F_d = Fd(alpha, rho, v) + 0*np.random.randn(N)

df_dict = {
    "alpha":alpha,
    "rho":rho,
    "velocity":v, 
    "f_drag":F_d
}

df = pd.DataFrame(df_dict)
```

```{python}
df.head()
```

Let's define our input features as $x(z) = (\alpha, \rho, v)^\top$. We can now form $\bX$ (our training inputs) and $\bY$ (our training outputs) matrices by extracting the input features and outputs from the dataframe: 

```{python}
# The hstack method concatenates column vectors into 
# an N x d matrix like [1 alpha rho velocity]
X = np.hstack((np.ones((N, 1)), df[['alpha', 'rho', 'velocity']].values)).T 
Y = df['f_drag'].values
```

We can solve for $\beta^*$ using the `np.linalg.lstsq()` function which efficiently solves the least-squares equation $\bX^\top \beta = \bY$. The `rcond` keyword argument specifies how "well-conditioned" we want our result to be, achieved by cutting off the smallest singular values of $\bX$ (don't worry too much about this for now). Setting it to `None` assumes $\bX$ is well-conditioned i.e. far from being rank-deficient. By default, the `lstsq()` function returns a list of the optimal weights, $\beta^*$, the residuals of the training data ($\bX^\top \beta - \bY$), the rank of $\bX^\top$, and the singular values of $\bX^\top$. For now, we're only interested in $\beta^*$, so we use `[0]` to select this value.  

```{python}
beta_hat = np.linalg.lstsq(X.T, Y, rcond=None)[0]
```

We are now able to compute the model's predictions at the training inputs: 

```{python}
Y_hat = X.T @ beta_hat
```

Let's now plot $\hat{\mathbf{Y}}$ and $\mathbf{Y}$ to examine how closely correlated the two are. A straight line with slope 1 would mean the linear regression model exactly matched all of the training outputs: 

```{python}
plt.figure(figsize=(8,4))
plt.scatter(Y, Y_hat)
plt.grid()
plt.xlabel("True Drag Force")
plt.ylabel("Model Predicted Drag Force")
```

This plot shows that there is clearly a strong, but nonlinear relationship between the true and model-predicted drag-force. We observe that the linear regression model under-predicts the drag-force when the true force is very low or very high and the model over-predicts the drag-force when the true force is around 5000N. This shows that when the relationship between the input features and the output is nonlinear, linear regression may provide good estimates on average, but choosing features to better capture this nonlinearity may provide much more accurate outputs over the entire input domain. 


## Assessing the learned models

various metrics, validation? definitely test data sets.

## Exercises

a few relatively short questions that test the learning outcomes. 

- math training: derive the derivative of the loss function by expanding, and then applying identities from [@petersen2012matrix]. Hard mode: prove the identities by calculation.

- math training/review: what does it mean for a matrix $A$ to be invertible (inverse exists, square and full rank, linearly independent rows/columns)

- math training: prove that $X^\top X$ is invertible iff $X$ has full column rank.

- math training: explain why the minimizer is unique iff $X^\top X$ is invertible... what happens if it's not invertible?

## Further reading

any appropriate links
---